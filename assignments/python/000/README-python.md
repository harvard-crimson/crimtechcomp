### Python

Ok, so by now you must know that we'll be using Python to run most things in our comp and at The Crimson. If you're a Python guru, then maybe you'll learn some nifty tricks and tips. If you've never seen Python before, then we hope to get you up to speed. 

We will assume that you've read through our tutorial on shell commands or are familiar with them so that you can create Python files and execute them somehow, either on the provided virtual machine or on your own laptop. 

Note: this assignment is designed to get difficult, and you're not expected to complete all of it. Honestly we only ask you to complete around half. If you're not super comfortable, then complete the first half, if you think you have Python down, then complete the latter half. If you're somewhere in between, complete somewhere in between!

Coding in general is really a matter of practice, so that's what we're going to do. This assignment is a bunch of practice problems ranging in difficulty, all written in Python. Below is the specification or spec, which tells you what to do with the skeleton code that we provide you. We don't want to bore you too much, so let's dive in (feel free to go at your own pace, but know that we will write this spec as if you're reading the whole thing).

-----

### Assignment Spec

1. So Python files usually end in ".py", this extension helps eveyone know that this is Python we're talking about. We've handed you a file "assignment.py", and we expect you to download it and then open it with the editor of your choice. You'll see plenty of code written there, but it's mostly what we'd call filler or placeholder. ```pass``` in Python is a keyword used to mean "something could go here, but I don't know what yet". Statements beginning with ```def``` are the declarations of functions, and there's a million other things we could overwhelm you with, but for now, let's just examine the first statement at the top: ```print("Hello, world!")```. Iconic. Take a guess as to what that statement does. You're probably right. Now take a guess as to how to get that statement to _run_ or _execute_. Maybe a little bit harder. In your terminal/console/shell of choice, navigate to the directory with "assignment.py" and run the command ```python3 assignment.py```. This should print "Hello, world!" to your console/terminal/shell. In general, this is a method for executing Python code (though certainly not the only way)!

2. We don't always want to print every time we run this file though, so we should stick that print statement into a function. Let's insert the statement ```def greet():``` above line 1, and then indent ```print("Hello, world!")``` with 4 spaces. Python cares about whether you mix tabs and spaces, so be consistent. Now, if we execute/run "assignment.py", we won't see any output! This is because in order to a function to run, it must be called, so if we add the line ```greet()``` somewhere in the file, then we will get the same output as in step 1. Don't forget to remove that line if you just tested that yourself, since our autograder won't like it! Congrats! You've written a function! Don't worry, you'll get plenty of practice with that!

3. Now that we've wrapped our print statement into a function, let's take a look at this line that starts with "#" or hash. This is a single-line comment in Python - it will not get executed. Replace the placeholder text with your favorite color please. (We know that you may ask what is the placeholder text, but we're asking you to make some inferences)

4. Let's write a slightly more useful function, ```add(x, y)```. We've already put it's declaration into the code, but we'll need you to fix the implementation. Functions take in arguments or parameters, in this case we've named those arguments "x" and "y", and they can be accessed in the body of the function (the indented part below "def"). The statement "return 0" means that any time we call this function, ```a = add(1, 0)```, ```b = add(42, -3.14)```, we will always get 0 back. This means that both "a" and "b" above will equal 0. That doesn't make any sense, so please fix the return statement so that it does what the function name suggests. 

5. Just wanted to make sure you got the message, do the same thing with "multiply(x, y)" - it should make sense.

6. Data structures - there are some crazy complex things that you can do in almost any CS language, but a lot of things remain the same and just get represented differently. This next function deals with manipulating lists, a data structure common to almost all languages (although represented and handled differently in each). Lists are ordered collections of objects, and in Python, they're very flexible. Take a look at the toy code we wrote in order to see a little bit about how a list works in Python. We don't really need you to do anything in this step, but you are welcome to use it as a reference in the next step. 

7. Now we're going to have you make use of lists. In order to do that, we're going to explain a command structure that you saw in step 6 - the for loop. for loops in Python are extremely user-friendly. They take the form of ```for element in iterable:``` where in the body of the for loop, you can access each element one at a time from the iterable (iterables are objects like lists, or others that we haven't discussed yet that can be iterated over, or walked over one element at a time). We will also introduce a function "range()", which you will often find useful. The function we have provided, "countdown(n)" should return a list of all numbers from "n" down through 0. It currently doesn't do that at all. Please fix it. For a moderate challenge, please implement countdown recursively - it should still take in an integer "n" and return a list of integers ordered [n, 0]. Don't worry we'll show recursion later too.

8. Ok let's do another thing with lists. We're going to use the "split()" method of strings to implement this function. Go check Google to see how "split()" works in Python, and then maybe play around with it in the Python REPL. When you're comfortable, this function should take in a string, "s" and then return to us a list of the number of letters in each word (assume that only spaces will separate words and that only the number of letters should be counted). For example: ```make_it_count("Hello Crimson")``` should return ```[5, 7]```. Good luck!

9. Ok what if we wanted to remove all duplicate numbers from a list? We could figure out how to do it, or we could be lazy and simply convert the list into a set. Sets are unordered collections of objects that do not allow for duplicates. This function should return lst without duplicates and as a set. You can do this conversion simply with ```set(lst)```. Play around with it, and see what happens.

10. Our last simple data structure is the dictionary. This takes in objects (frequently strings) as keys, and maps them to other objects, the values. This key-value pairing is extremely useful, and dictionaries are super common. They're notorious for being extremely quick to find items. Similar to when we introduced lists, just look at this function's contents for some examples of how to use a dictionary. 

11. Now let's build a function with dictionaries. This function "trevni(d)" should take in a dictionary (we will assume that this dictionary does not contain any duplicate values, so all keys AND values are unique). Then, the function should return the dictionary, inverted. This means that all values should now be keys mapping to what their keys were. For example: ```trevni({"name": "Nick", "age": 20})``` should return ```{"Nick": "name", 20: "age"}```. This is actually a useful function. Note: this inversion function does not need to invert nested dictionaries. 

12. Alright, the first topic that tends to scare people - recursion. It's tricky, and we know that. Almost everyone has trouble with it at the beginning, so we're gonna give you a bunch of practice. Recursive functions often have two cases - the base case and the other one. We've written a simple recursive function for you to look at. As the name suggests, it's stupid. We check the first number passed to the function, _i_, and see if it's 0 or less. If it is, then we return the second number that was passed. Otherwise, we subtract 1 from _i_, and then call the very same function that is currently executing. This is why a comedic definition of recursion is that "recursion is defined as recursion". Because recursive functions rely on themselves as part of their definition. Something to keep in mind is that for loops can ALWAYS be used to accomplish the same task (imagine in your head how you might do that here). However, sometimes it's more convenient or readable to do it this way. Occasionally, there are performance benefits. There are also different kinds of recursive, some of which are more memory-efficient, for example. We aren't going to worry about any of that here, but just know that there's always more to dive into with CS. 

13. If you thought we were going to let you off easy, maybe you're right! Regardless, the next few problems are some classic recursion problems. For instance, please replace our silly function with a proper version of factorial. Given an input _n_, this function should reasonably return _n_ factorial. ```factorial(4) => 24```. Don't worry about accounting for high number bounds or error checking, etc. 

14. Another classic case of common recursion problems - Fibonacci numbers. This function should take in a number _n_ and return the nth Fibonacci number. For example, input 3 and you should get 2 back. ```fibonacci(5) => 5``. 

15. A nice use for recursion is in sorting algorithms. This problem is a simple introduction to binary sort. We ask you to, given an input list of integers, sort them from lowest to highest. Your input list will contain only integers, but they may repeat and may be negative, 0, or positive. We will not test extremely large or small numbers.

16. In case you haven't gotten enough practice, we have one more recursive problem for you. Given a dictionary mapping unique children as keys to their parents and given a child, can you find the highest parent of a given child? For example: ```{5: 2, 4: 2, 3: 1, 2: 1, 1: None}``` represents one such tree, where 1 is the highest parent, with 2 children, 2 and 3, and 2 has 2 children, 4 and 5. Your input dictionary may not always represent a binary tree, but it will always follow this structure: keys are children mapping to parents, and the highest node in a given branch will always map to None. 

17. Alright! Now we're going to switch gears a bit and talk about one of the most powerful aspects of OOP (Object Oriented Programming, not oop) - Classes. Everything in Python is an object, which means that it has a class, which is a specification for how that object behaves and what it is. We've written a dummy class in order for you to see a bit of syntax and get some context for what we're talking about. Our Human class requires that in order to create a Human object, you need to give it a name: ```h = Human("Nick")```, and then the rest is setup for you! Our new human can eat a given food ```h.eat("sugar")```, can walk ```h.walk(speed=2)```, aaaaanddd not much else. 

18. Now, here's more example code (dw, we'll let you get back to coding in a sec). In this case, we're actually making a class that will _inherit_ from the Human class. This means that by default, this class has all the same attributes and methods of the Human class (more generally, the parent class). We can add methods and attributes to the new class, such as the new method, _cry(self, duration=10)_. We can also override previous methods or modify their behavior by defining methods of the same name and by using the _super()_ function, as we did in _walk()_. Note that this toy example should be somewhat intuitive, and if you have trouble with it, please spend some time to understand how Python classes work. 

19. And now we'll ask you to fill out our dummy function here. It shouldn't rely on functions you wrote in the past, though we understand why you may want to do something like that! The functions and their names should all be intuitive - everything will be done with integers, and you do not have to check for special cases. We implemented two methods to get you started.

20. Guess what! Inheritance! We've set up some skeleton code for you to use, but we want you to implement 2 basic new functions for us. Except, they're not new at all - you saw them in the recursive portion. So what's the challenge, you may ask. And we will answer - we're annoying! We require that you not use any basic Python functions, like "+", "-", "/", or "*". Like truly young software developers, we've reinvented the wheel, and we want to use our shiny new wheels. Thus, you must use the inherited class' versions of those functions in implementing your 2 new ones. AND, we require that you implement these functions iteratively, with for loops. No recursion!

21. For a small challenge, we've asked you to implement a basic Graph class. We've given you all the skeleton code you should need. Good luck, and remember not to change our function signatures (all return types and input types/orders/etc should remain the same). 

22. For another quick challenge, we ask you to implement a quick binary tree class. Before you ask for clarification, note that as long as _add\_node()_ and _find\_node()_  work correctly, our autograder will work. All the same rules from #21 apply!

23. While we would love to give you more challenging problems, this concludes this assignment. We expect that after completing this, you will have seen most of Python's basic data types, and you will be getting familiar with Python syntax. As always, please let us know if you have any questions, and submit!